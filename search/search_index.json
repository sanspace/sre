{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welcome to the SRE!","text":"<p>Your comprehensive guide to mastering Site Reliability Engineering.</p>"},{"location":"index.html#chart-your-course-to-sre-excellence","title":"Chart Your Course to SRE Excellence","text":"<p>Navigating the path to becoming a Site Reliability Engineer (SRE) can be challenging. This site aims to be your go-to resource, consolidating essential topics, key concepts, practical knowledge, and valuable links to help you prepare for an SRE role and excel in your SRE journey.</p> <p>Whether you're just starting out, looking to switch careers, or aiming to deepen your existing SRE skills, you'll find structured information to guide your learning.</p>"},{"location":"index.html#what-youll-find-inside","title":"What You'll Find Inside:","text":"<p>This site is designed to be a living repository of SRE knowledge, covering a wide array of domains crucial for the role. We are continuously working to expand and refine the content.</p> <ul> <li>Core SRE Principles: Understand the foundations of SRE, including Service Level Objectives (SLOs), error budgets, and the importance of reliability.</li> <li>Essential Technical Skills: Dive into key technical areas such as:<ul> <li>Operating Systems (with a focus on Linux)</li> <li>Networking Fundamentals</li> <li>Web Technologies &amp; Architectures</li> <li>Troubleshooting Methodologies</li> </ul> </li> <li>SRE Practices: Learn about incident response, postmortems, monitoring, automation, and managing toil.</li> <li>Tools of the Trade: Get familiar with common tools and technologies used by SREs.</li> <li>And much more... We're actively collecting and curating information on everything from distributed systems to security and FinOps in an SRE context.</li> </ul>"},{"location":"index.html#how-to-use-this-site","title":"How to Use This Site:","text":"<ol> <li>Explore Topics: Use the navigation bar to browse through different SRE domains. Your existing navigation already includes:<ul> <li>SLOs</li> <li>Error Budgets</li> <li>Incident Response</li> <li>Postmortems</li> <li>Monitoring &amp; Alerting</li> <li>Toil &amp; Automation</li> <li>Capacity Planning</li> <li>Change Management</li> <li>SRE Best Practices</li> <li>Tools &amp; Technologies</li> <li>Learning Resources</li> <li>Chaos Engineering</li> <li>Security</li> <li>FinOps (We'll integrate \"Operating Systems,\" \"Troubleshooting,\" and \"Web Tech\" into this structure soon!)</li> </ul> </li> <li>Deep Dive: Each section aims to provide reference material, explanations, and links to further reading.</li> <li>Contribute (Coming Soon!): We believe in the power of community. In the future, we aim to open up contributions to make this an even richer resource.</li> </ol> <p>Ready to begin? Start by exploring a topic from the navigation menu or check out our About page to learn more about this initiative.</p> <p>Happy learning!</p>"},{"location":"about.html","title":"About This SRE Reference Site","text":""},{"location":"about.html#our-mission","title":"Our Mission","text":"<p>The world of Site Reliability Engineering (SRE) is vast and ever-evolving. Our mission with this site is to create a centralized, accessible, and practical knowledge base to help aspiring and practicing SREs navigate this landscape. We aim to collect, curate, and present key topics, foundational concepts, best practices, and useful resources required to prepare for SRE roles and to grow as an SRE professional.</p>"},{"location":"about.html#why-this-site","title":"Why This Site?","text":"<p>As SRE principles become increasingly critical for building and maintaining resilient, scalable, and efficient systems, the demand for skilled SREs continues to grow. We noticed a need for a consolidated reference point that not only lists topics but also provides context and pathways for learning. This site is an effort to fill that gap, offering a structured approach to SRE preparation.</p>"},{"location":"about.html#what-we-hope-to-achieve","title":"What We Hope to Achieve","text":"<ul> <li>Clarity: Demystify complex SRE concepts.</li> <li>Comprehensiveness: Cover a broad spectrum of SRE knowledge, from fundamentals to advanced practices.</li> <li>Practicality: Focus on information that is directly applicable to SRE roles and interviews.</li> <li>Community (Future Goal): Eventually, foster a community where SREs can share knowledge and help each other grow.</li> </ul>"},{"location":"about.html#who-is-this-for","title":"Who Is This For?","text":"<ul> <li>Software engineers looking to transition into an SRE role.</li> <li>System administrators aiming to adopt SRE practices.</li> <li>Students and new graduates aspiring to start a career in SRE.</li> <li>Existing SREs seeking a quick reference or wanting to brush up on specific topics.</li> </ul>"},{"location":"about.html#a-living-resource","title":"A Living Resource","text":"<p>This site is a dynamic project. The information landscape for SREs is constantly changing, and we intend for this site to evolve with it. We will be adding new topics, updating existing content, and incorporating new resources over time.</p> <p>We hope you find this site valuable on your SRE journey!</p>"},{"location":"linux/processes.html","title":"Understanding Linux Processes","text":"<p>A process is an instance of a running program. For an SRE, understanding how to manage and inspect processes is fundamental for troubleshooting, performance analysis, and ensuring system reliability.</p>"},{"location":"linux/processes.html#what-is-a-process","title":"What is a Process?","text":"<p>When you execute a program, the operating system creates a process. Each process has its own address space, system resources (like file descriptors), and a unique Process ID (PID).</p> <p>Key Attributes of a Process:</p> <ul> <li>PID (Process ID): A unique integer that identifies the process.</li> <li>PPID (Parent Process ID): The PID of the process that created this process. Most processes are children of <code>init</code> (PID 1) or <code>systemd</code> (PID 1).</li> <li>UID/GID (User ID/Group ID): The user and group that own the process, determining its permissions.</li> <li>State: Processes can be in various states:<ul> <li>R (Running or Runnable): Actively using the CPU or waiting for its turn.</li> <li>S (Interruptible Sleep): Waiting for an event to complete (e.g., I/O, a signal).</li> <li>D (Uninterruptible Sleep): Usually waiting for I/O (e.g., disk activity) and cannot be interrupted by signals. High numbers of these can indicate I/O problems.</li> <li>T (Stopped or Traced): Stopped by a job control signal (e.g., Ctrl+Z) or because it's being debugged.</li> <li>Z (Zombie): A process that has completed execution, but its entry still remains in the process table because its parent has not yet read its exit status. Too many zombies can (rarely) exhaust PIDs.</li> </ul> </li> <li>Priority &amp; Niceness: Values that influence how the OS schedules the process.</li> </ul>"},{"location":"linux/processes.html#processes-threads-and-multiprocessing","title":"Processes, Threads, and Multiprocessing","text":"<ul> <li>Process: An independent program with its own memory space. Creating a new process (forking) is relatively expensive. Communication between processes (Inter-Process Communication - IPC) requires explicit mechanisms (pipes, sockets, shared memory).</li> <li>Thread: A lightweight unit of execution within a process. Threads share the same memory space as their parent process and other threads within that process. This makes communication between threads easier and creation/context-switching faster than processes.</li> <li>Multiprocessing: Using multiple processes (CPUs/cores) to execute parts of a program or multiple programs simultaneously.</li> <li>Multithreading: Using multiple threads within a single process to perform tasks concurrently, often improving responsiveness and throughput for I/O-bound or parallelizable tasks within that process.</li> </ul> <p>SRE Perspective: - Understanding if an application is single-threaded, multi-threaded, or uses multiple processes helps in diagnosing performance bottlenecks. - A single-threaded application might not fully utilize a multi-core CPU for CPU-bound tasks. - Issues in one thread can sometimes impact other threads in the same process. - Knowing how an application scales (more processes vs. more threads) is crucial for capacity planning.</p>"},{"location":"linux/processes.html#viewing-and-inspecting-processes","title":"Viewing and Inspecting Processes","text":"<p>Several commands help you view and inspect running processes:</p>"},{"location":"linux/processes.html#1-ps-process-status","title":"1. <code>ps</code> (Process Status)","text":"<p>The <code>ps</code> command provides a snapshot of the currently running processes. It has many options:</p> <ul> <li><code>ps aux</code>: Shows all processes (a=all, u=user-oriented format, x=processes without a controlling terminal). This is a very common and informative invocation.     Bash<pre><code># Example output (truncated)\n# USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\n# root         1  0.0  0.1 169560 13188 ?        Ss   Apr23   0:30 /sbin/init\n# root         2  0.0  0.0      0     0 ?        S    Apr23   0:00 [kthreadd]\n# user1     1234  0.5  2.5 876543 54321 ?        Sl   10:00   0:15 /usr/bin/my-application\n</code></pre></li> <li><code>ps ef</code>: Shows all processes (e=all, f=full-format listing, often showing process hierarchy).     Bash<pre><code># Example output showing hierarchy (truncated)\n# UID        PID  PPID  C STIME TTY          TIME CMD\n# root         1     0  0 Apr23 ?        00:00:30 /sbin/init\n# root      1000     1  0 Apr23 ?        00:00:05  \\_ /usr/lib/systemd/systemd-journald\n# user1     1234  1000  0 10:00 ?        00:00:15      \\_ /usr/bin/my-application -c /etc/app.conf\n</code></pre></li> <li><code>ps -p &lt;PID&gt;</code>: Show information about a specific PID.</li> <li><code>ps -u &lt;username&gt;</code>: Show processes owned by a specific user.</li> <li><code>ps -C &lt;commandname&gt;</code>: Show processes by command name.</li> </ul> <p>SRE Perspective: - Identify which user is running a process. - Find the PID of a misbehaving application. - Check if expected daemons or services are running. - View command-line arguments to understand how a process was started.</p>"},{"location":"linux/processes.html#2-top","title":"2. <code>top</code>","text":"<p>An interactive, real-time view of system processes. Processes are typically sorted by CPU usage by default.</p> <ul> <li>Key Information in <code>top</code>: PID, USER, PR (Priority), NI (Nice value), VIRT (Virtual Memory), RES (Resident Memory), SHR (Shared Memory), S (Status), %CPU, %MEM, TIME+ (CPU Time), COMMAND.</li> <li>Interactive Commands (while <code>top</code> is running):<ul> <li><code>k</code>: Kill a process (prompts for PID and signal).</li> <li><code>r</code>: Renice a process (change priority).</li> <li><code>M</code>: Sort by memory usage.</li> <li><code>P</code>: Sort by CPU usage (default).</li> <li><code>u</code>: Filter by user.</li> <li><code>q</code>: Quit.</li> <li><code>1</code>: Toggle display of individual CPU core statistics.</li> </ul> </li> </ul>"},{"location":"linux/processes.html#3-htop","title":"3. <code>htop</code>","text":"<p>An enhanced, more user-friendly interactive process viewer (often needs to be installed separately, e.g., <code>sudo apt install htop</code> or <code>sudo yum install htop</code>).</p> <ul> <li>Features: Colorized display, easier scrolling, tree view, direct F-key shortcuts for actions like kill, renice.</li> <li>Generally preferred over <code>top</code> for interactive use if available.</li> </ul> <p>SRE Perspective for <code>top</code>/<code>htop</code>: - Quickly identify processes consuming the most CPU or memory right now. - Monitor system load and resource utilization in real-time. - Interactively manage processes (kill, renice) during an incident if necessary (with caution).</p>"},{"location":"linux/processes.html#sending-signals-to-processes-kill-pkill-killall","title":"Sending Signals to Processes (<code>kill</code>, <code>pkill</code>, <code>killall</code>)","text":"<p>Signals are a way to communicate with processes, often to request them to terminate or change behavior.</p> <ul> <li><code>kill &lt;PID&gt;</code>: Sends a signal to the specified PID. By default, sends <code>SIGTERM (15)</code>.     Bash<pre><code>kill 1234 # Sends SIGTERM to PID 1234\nkill -9 1234 # Sends SIGKILL to PID 1234 (force kill)\nkill -l # Lists all available signals\n</code></pre></li> <li><code>pkill &lt;process_name&gt;</code>: Sends a signal to processes matching a name or other criteria.     Bash<pre><code>pkill my-application # Sends SIGTERM to all processes named 'my-application'\npkill -u user1 defunct-app # Sends SIGTERM to 'defunct-app' run by 'user1'\n</code></pre></li> <li><code>killall &lt;process_name&gt;</code>: Similar to <code>pkill</code>, sends a signal to all processes matching the exact command name. (Behavior can vary slightly from <code>pkill</code>).     Bash<pre><code>killall -s SIGINT my-webserver\n</code></pre></li> </ul> <p>Common Signals for SREs:</p> <ul> <li><code>1</code> or <code>SIGHUP</code> (Hang Up): Often used to tell a daemon to reload its configuration file.</li> <li><code>2</code> or <code>SIGINT</code> (Interrupt): Sent when you press <code>Ctrl+C</code>. Usually requests graceful termination.</li> <li><code>9</code> or <code>SIGKILL</code> (Kill): The \"unkillable\" kill signal. Forces immediate termination. The process doesn't get a chance to clean up. Use as a last resort as it can lead to data corruption or unclean state.</li> <li><code>15</code> or <code>SIGTERM</code> (Terminate): The default signal for <code>kill</code>. Requests graceful termination. The process can catch this signal and perform cleanup operations before exiting. Always try this before <code>SIGKILL</code>.</li> </ul> <p>SRE Perspective: - Graceful Shutdown: Use <code>SIGTERM</code> to allow applications to shut down cleanly (save state, close connections). - Force Termination: Use <code>SIGKILL</code> for unresponsive processes that don't respond to <code>SIGTERM</code>, but understand the risks. - Configuration Reloads: Use <code>SIGHUP</code> for services that support it to reload configurations without a full restart, minimizing downtime. - Automating process restarts or cleanup often involves sending specific signals.</p>"},{"location":"linux/processes.html#sre-scenarios-involving-processes","title":"SRE Scenarios Involving Processes:","text":"<ul> <li>High CPU/Memory Usage: Identifying which process is consuming excessive resources using <code>top</code>, <code>htop</code>, or <code>ps</code>.</li> <li>Unresponsive Application: Determining if a process is hung, in an uninterruptible sleep (D state), or not responding to normal signals.</li> <li>Zombie Processes: Checking for an accumulation of zombie processes (<code>Z</code> state in <code>ps</code>) which might indicate a bug in a parent process not reaping its children.</li> <li>Service Management: Ensuring critical application processes are running and restarting them if they fail (often handled by <code>systemd</code> or other init systems, but manual checks are sometimes needed).</li> <li>Resource Limits: Understanding how process resource limits (ulimits) can affect application behavior.</li> <li>Debugging: Using process information as a starting point for deeper debugging with tools like <code>strace</code>, <code>lsof</code>, or debuggers.</li> </ul>"}]}